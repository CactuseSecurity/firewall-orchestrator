[Unit]
Description={{ product_name }} API
Requires=docker.service
{% if 'databaseserver' in group_names -%}
After=network.target remote-fs.target nss-lookup.target postgresql.service docker.service
{% else -%}
After=network.target remote-fs.target nss-lookup.target docker.service
{%- endif %}
[Service]
Restart=on-failure
SuccessExitStatus=0 137 143
WorkingDirectory={{ fworch_home }}
ExecStart=/bin/bash -c '\
  if /usr/bin/docker inspect -f "{% raw %}{{.State.Running}}{% endraw %}" {{ api_container_name }} 2>/dev/null | grep -q true; then \
    exec /usr/bin/docker attach {{ api_container_name }}; \
  fi; \
  exec /usr/bin/docker start -a {{ api_container_name }} \
'
ExecStop=/usr/bin/docker stop -t 2 {{ api_container_name }}
StandardOutput=journal
StandardError=journal
SyslogIdentifier={{ product_name }}-api
User={{ fworch_user }}
[Install]
WantedBy=default.target

# Explanation of SuccessExitStatus:
# extra exit codes that systemd should treat as “success” instead of failure:
#   0 normal success.
# 137 process exited due to signal 9 (128+9), i.e., killed/SIGKILL (common when a container is stopped forcefully).
# 143 process exited due to signal 15 (128+15), i.e., SIGTERM (the normal stop path).
# Now a clean container stop (SIGTERM) or a forced stop (SIGKILL) does not leave the unit in a failed state.