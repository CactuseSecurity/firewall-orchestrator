- block:
      # install libs needed for nuget package PuppeteerSharp
      - name: Define core packages
        set_fact:
            core_packages:
                - ca-certificates
                - fonts-liberation
                - libappindicator3-1
                - libatk-bridge2.0-0
                - libatk1.0-0
                - libcups2
                - libdbus-1-3
                - libdrm2
                - libgbm1
                - libnspr4
                - libnss3
                - libx11-xcb1
                - libxcomposite1
                - libxdamage1
                - libxrandr2
                - xdg-utils

      - name: Define default platform-specific library names
        set_fact:
            glib_library: libglib2.0-0
            sound_library: libasound2

      - name: Define new library names based on newer OS versions
        set_fact:
            glib_library: libglib2.0-0t64
            sound_library: libasound2t64
        when: >
            ansible_facts['distribution'] == "Ubuntu" and ansible_facts['distribution_version'] | float >= 24.04
            or ansible_facts['distribution'] == "Debian" and ansible_facts['distribution_version'] | float >= 13
            or ansible_facts['distribution'] == "Debian" and ansible_lsb.codename == "trixie"

      - block: # only use apparmor for ubuntu 24.04ff
            - name: Ensure the /etc/apparmor.d directory exists
              file:
                  path: /etc/apparmor.d
                  state: directory
                  mode: "0755"

            - name: Create /etc/apparmor.d/chrome
              copy:
                  dest: /etc/apparmor.d/chrome
                  content: |
                      abi <abi/4.0>,
                      include <tunables/global>

                      profile /usr/local/fworch/bin/**/chrome flags=(unconfined) {
                          userns,

                          # Site-specific additions and overrides. See local/README for details.
                          # Include the local overrides only if the file exists.
                          # This is a common best practice to avoid parser errors.
                          include if exists <local/chrome>
                      }
                  mode: "0644"
              notify:
                  - Reload and Restart AppArmor

        when: ansible_facts['distribution'] == "Ubuntu" and ansible_facts['distribution_version'] | float >= 24.04

      - name: Install additional libraries for old Debian 11
        apt:
            name:
                - libpangocairo-1.0-0
                - libpangoft2-1.0-0
            state: present
            update_cache: yes
        when: ansible_facts['distribution'] == "Debian" and ansible_facts['distribution_version'] == "11"

      - name: Combine all packages
        set_fact:
            platform_packages: "{{ core_packages + [sound_library, glib_library] }}"

      - name: Install all combined dependencies
        apt:
            name: "{{ platform_packages }}"
            state: present
            update_cache: yes

  become: true
  environment: "{{ proxy_env }}"

# get google chrome for pdf generation
- block:
      - name: get last known good versions (primary)
        uri:
            url: https://googlechromelabs.github.io/chrome-for-testing/last-known-good-versions-with-downloads.json
            return_content: true
        register: chrome_versions
        become: false

  rescue:
      - name: fallback - get last known good versions (raw.githubusercontent.com)
        uri:
            url: https://raw.githubusercontent.com/GoogleChromeLabs/chrome-for-testing/main/data/last-known-good-versions-with-downloads.json
            return_content: true
            headers:
                Accept: application/json
        register: chrome_versions
        become: false

# Parse once, regardless of Content-Type
- name: normalize/parse JSON response
  set_fact:
      chrome_versions_parsed: >-
          {{
            chrome_versions.json
            if (chrome_versions.json is defined)
            else (chrome_versions.content | trim | from_json)
          }}

# Pick the Stable channel (some users accidentally use 'stable', so be flexible)
- name: select Stable channel
  set_fact:
      cft_stable: "{{ chrome_versions_parsed.channels.Stable | default(chrome_versions_parsed.channels.stable) }}"

# Extract downloads + version from Stable
- name: parse latest stable versions for chrome #and headless shell
  set_fact:
      stable_chrome_versions: "{{ cft_stable.downloads }}"
      chrome_dest: "/usr/local/fworch/bin/Chrome/Linux-{{ cft_stable.version }}"

# (Optional) sanity checks to fail early with a clear message
- name: validate parsed data
  assert:
      that:
          - chrome_versions_parsed is mapping
          - cft_stable is mapping
          - cft_stable.version is defined
          - cft_stable.downloads is defined
      fail_msg: "Failed to parse Chrome for Testing JSON or locate the Stable channel."

- block:
      - name: install unzip
        package:
            name: unzip
            state: present

      - name: create chrome install path
        file:
            path: "{{ chrome_dest }}"
            state: directory
            mode: "0755"

      # Figure out the target (remote) Chrome URL and MAJOR version
      - name: set chrome URL and archive path
        set_fact:
            chrome_url: >-
                {{ stable_chrome_versions['chrome']
                   | selectattr('platform', 'match', 'linux64')
                   | map(attribute='url') | first }}
            chrome_archive: >-
                {{ chrome_dest }}/{{ (
                    stable_chrome_versions['chrome']
                    | selectattr('platform','match','linux64')
                    | map(attribute='url') | first
                  ) | urlsplit('path') | basename }}

      # If your data has an explicit 'version' attribute, prefer that.
      # Otherwise, fall back to parsing the version from the URL.
      - name: derive target chrome major version
        set_fact:
            target_version_full: >-
                {{ (stable_chrome_versions['chrome']
                    | selectattr('platform','match','linux64')
                    | map(attribute='version') | first) | default('', true) }}
            target_major_fallback: "{{ chrome_url | regex_search('\\d+') }}"
      - name: finalize target major version
        set_fact:
            target_major: >-
                {{ (target_version_full | regex_search('\\d+'))
                   | default(target_major_fallback, true) | int }}

      # Detect currently installed Chrome major version (if present)
      - name: check if chrome is installed (via symlinked bin)
        stat:
            path: "{{ fworch_home }}/bin/chrome"
        register: chrome_bin

      - name: read installed chrome version
        command: "{{ fworch_home }}/bin/chrome --version"
        register: installed_ver
        changed_when: false
        failed_when: false
        when: chrome_bin.stat.exists

      - name: parse installed major version (defaults to 0 when absent)
        set_fact:
            installed_major: >-
                {{ (installed_ver.stdout | default('') | regex_search('\\d+'))
                   | default(0, true) | int }}

      - name: decide if update is needed (only on major bump)
        set_fact:
            chrome_major_update_needed: "{{ target_major != installed_major }}"

      # Only download when the MAJOR version changed or Chrome isn't installed
      - name: download google chrome archive (only on major change)
        get_url:
            url: "{{ chrome_url }}"
            dest: "{{ chrome_archive }}"
            mode: "0644"
            force: no
            timeout: 60
        register: chrome_pkg
        when: chrome_major_update_needed or (not chrome_bin.stat.exists)

      - name: unpack chrome when archive downloaded
        unarchive:
            src: "{{ chrome_archive }}"
            dest: "{{ chrome_dest }}"
            remote_src: yes
        when: chrome_pkg is defined and chrome_pkg.changed

      - name: create symlinks {{ chrome_dest }}/chrome-linux64 to {{ fworch_home }}/bin/*
        file:
            src: "{{ chrome_dest }}/chrome-linux64/{{ item }}"
            dest: "{{ fworch_home }}/bin/{{ item }}"
            state: link
        loop:
            - chrome
            - chrome-wrapper
            - chrome_crashpad_handler
            - chrome_sandbox

      - name: add {{ fworch_home }}/bin to every users path
        copy:
            dest: /etc/profile.d/custom_path.sh
            content: 'export PATH="{{ fworch_home }}/bin:$PATH"'
            mode: "0644"

  become: true
  environment: "{{ proxy_env }}"
