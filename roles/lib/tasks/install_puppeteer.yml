- block:
      # install libs needed for nuget package PuppeteerSharp
      - name: Define core packages
        set_fact:
            core_packages:
                - ca-certificates
                - fonts-liberation
                - libappindicator3-1
                - libatk-bridge2.0-0
                - libatk1.0-0
                - libcups2
                - libdbus-1-3
                - libdrm2
                - libgbm1
                - libnspr4
                - libnss3
                - libx11-xcb1
                - libxcomposite1
                - libxdamage1
                - libxrandr2
                - xdg-utils

      - name: Define default platform-specific library names
        set_fact:
            glib_library: libglib2.0-0
            sound_library: libasound2

      - name: Define new library names based on newer OS versions
        set_fact:
            glib_library: libglib2.0-0t64
            sound_library: libasound2t64
        when: >
            ansible_facts['distribution'] == "Ubuntu" and ansible_facts['distribution_version'] | float >= 24.04
            or ansible_facts['distribution'] == "Debian" and ansible_facts['distribution_version'] | float >= 13
            or ansible_facts['distribution'] == "Debian" and ansible_lsb.codename == "trixie"

      - block: # only use apparmor for ubuntu 24.04ff
            - name: Ensure the /etc/apparmor.d directory exists
              file:
                  path: /etc/apparmor.d
                  state: directory
                  mode: "0755"

            - name: Create /etc/apparmor.d/chrome
              copy:
                  dest: /etc/apparmor.d/chrome
                  content: |
                      abi <abi/4.0>,
                      include <tunables/global>

                      profile /usr/local/fworch/bin/**/chrome flags=(unconfined) {
                          userns,

                          # Site-specific additions and overrides. See local/README for details.
                          # Include the local overrides only if the file exists.
                          # This is a common best practice to avoid parser errors.
                          include if exists <local/chrome>
                      }
                  mode: "0644"
              notify:
                  - Reload and Restart AppArmor

        when: ansible_facts['distribution'] == "Ubuntu" and ansible_facts['distribution_version'] | float >= 24.04

      - name: Install additional libraries for old Debian 11
        apt:
            name:
                - libpangocairo-1.0-0
                - libpangoft2-1.0-0
            state: present
            update_cache: yes
        when: ansible_facts['distribution'] == "Debian" and ansible_facts['distribution_version'] == "11"

      - name: Combine all packages
        set_fact:
            platform_packages: "{{ core_packages + [sound_library, glib_library] }}"

      - name: Install all combined dependencies
        apt:
            name: "{{ platform_packages }}"
            state: present
            update_cache: yes

  become: true
  environment: "{{ proxy_env }}"

# get google chrome for pdf generation
- name: get last known good versions (primary)
  uri:
      url: https://googlechromelabs.github.io/chrome-for-testing/last-known-good-versions-with-downloads.json
      return_content: true
  register: chrome_versions_primary
  failed_when: false
  become: false
  environment: "{{ proxy_env }}"

- name: get last known good versions (GitHub API raw)
  uri:
      url: https://api.github.com/repos/GoogleChromeLabs/chrome-for-testing/contents/data/last-known-good-versions-with-downloads.json?ref=main
      headers:
          Accept: application/vnd.github.v3.raw
      return_content: true
  register: chrome_versions_github_api
  failed_when: false
  become: false
  environment: "{{ proxy_env }}"

- name: fallback - get last known good versions (raw.githubusercontent.com)
  uri:
      url: https://raw.githubusercontent.com/GoogleChromeLabs/chrome-for-testing/main/data/last-known-good-versions-with-downloads.json
      return_content: true
      headers:
          Accept: application/json
  register: chrome_versions_fallback
  failed_when: false
  become: false
  environment: "{{ proxy_env }}"

- name: load bundled chrome metadata when network is blocked
  set_fact:
      chrome_versions_local_content: "{{ lookup('file', chrome_versions_local_path | default(role_path + '/files/chrome/last-known-good-versions-with-downloads.json'), errors='ignore') }}"
  when:
      - chrome_versions_primary.status | default(-1) != 200
      - chrome_versions_github_api.status | default(-1) != 200
      - chrome_versions_fallback.status | default(-1) != 200

- name: pick chrome metadata source (primary -> fallback -> bundled)
  set_fact:
      chrome_versions: >-
          {{
            chrome_versions_primary
            if (chrome_versions_primary.status | default(-1)) == 200 else
            (
              chrome_versions_github_api
              if (chrome_versions_github_api.status | default(-1)) == 200 else
              (
                chrome_versions_fallback
                if (chrome_versions_fallback.status | default(-1)) == 200 else
                {'content': chrome_versions_local_content}
              )
            )
          }}

- name: fail when no chrome metadata available
  fail:
      msg: >-
          Could not fetch Chrome for Testing version metadata.
          Allow proxy access, or set chrome_versions_local_path to a reachable JSON file.
  when: chrome_versions.content is not defined or (chrome_versions.content | string | trim | length) == 0

# Parse once, regardless of Content-Type
- name: normalize/parse JSON response
  set_fact:
      chrome_versions_parsed: >-
          {{
            chrome_versions.json
            if (chrome_versions.json is defined)
            else (chrome_versions.content | trim | from_json)
          }}

# Pick the Stable channel (some users accidentally use 'stable', so be flexible)
- name: select Stable channel
  set_fact:
      cft_stable: "{{ chrome_versions_parsed.channels.Stable | default(chrome_versions_parsed.channels.stable) }}"

# Extract downloads + version from Stable
- name: parse latest stable versions for chrome #and headless shell
  set_fact:
      stable_chrome_versions: "{{ cft_stable.downloads }}"
      chrome_dest: "/usr/local/fworch/bin/Chrome/Linux-{{ cft_stable.version }}"

# (Optional) sanity checks to fail early with a clear message
- name: validate parsed data
  assert:
      that:
          - chrome_versions_parsed is mapping
          - cft_stable is mapping
          - cft_stable.version is defined
          - cft_stable.downloads is defined
      fail_msg: "Failed to parse Chrome for Testing JSON or locate the Stable channel."

- block:
      - name: install unzip
        package:
            name: unzip
            state: present

      - name: create chrome install path
        file:
            path: "{{ chrome_dest }}"
            state: directory
            mode: "0755"

      # Figure out the target (remote) Chrome URL and MAJOR version
      - name: set chrome URL and archive path
        set_fact:
            chrome_url: >-
                {{ stable_chrome_versions['chrome']
                   | selectattr('platform', 'match', 'linux64')
                   | map(attribute='url') | first }}
            chrome_archive: >-
                {{ chrome_dest }}/{{ (
                    stable_chrome_versions['chrome']
                    | selectattr('platform','match','linux64')
                    | map(attribute='url') | first
                  ) | urlsplit('path') | basename }}

      # If your data has an explicit 'version' attribute, prefer that.
      # Otherwise, fall back to parsing the version from the URL.
      - name: derive target chrome major version
        set_fact:
            target_version_full: >-
                {{ (stable_chrome_versions['chrome']
                    | selectattr('platform','match','linux64')
                    | map(attribute='version') | first) | default('', true) }}
            target_major_fallback: "{{ chrome_url | regex_search('\\d+') }}"
      - name: finalize target major version
        set_fact:
            target_major: >-
                {{ (target_version_full | regex_search('\\d+'))
                   | default(target_major_fallback, true) | int }}

      # Detect currently installed Chrome major version (if present)
      - name: check if chrome is installed (via symlinked bin)
        stat:
            path: "{{ fworch_home }}/bin/chrome"
        register: chrome_bin

      - name: read installed chrome version
        command: "{{ fworch_home }}/bin/chrome --version"
        register: installed_ver
        changed_when: false
        failed_when: false
        when: chrome_bin.stat.exists

      - name: parse installed major version (defaults to 0 when absent)
        set_fact:
            installed_major: >-
                {{ (installed_ver.stdout | default('') | regex_search('\\d+'))
                   | default(0, true) | int }}

      - name: decide if update is needed (only on major bump)
        set_fact:
            chrome_major_update_needed: "{{ target_major != installed_major }}"

      # Only download when the MAJOR version changed or Chrome isn't installed
      - name: download google chrome archive (only on major change)
        get_url:
            url: "{{ chrome_url }}"
            dest: "{{ chrome_archive }}"
            mode: "0644"
            force: no
            timeout: 60
        register: chrome_pkg
        when: chrome_major_update_needed or (not chrome_bin.stat.exists)

      - name: unpack chrome when archive downloaded
        unarchive:
            src: "{{ chrome_archive }}"
            dest: "{{ chrome_dest }}"
            remote_src: yes
        when: chrome_pkg is defined and chrome_pkg.changed

      - name: create symlinks {{ chrome_dest }}/chrome-linux64 to {{ fworch_home }}/bin/*
        file:
            src: "{{ chrome_dest }}/chrome-linux64/{{ item }}"
            dest: "{{ fworch_home }}/bin/{{ item }}"
            state: link
        loop:
            - chrome
            - chrome-wrapper
            - chrome_crashpad_handler
            - chrome_sandbox

      - name: add {{ fworch_home }}/bin to every users path
        copy:
            dest: /etc/profile.d/custom_path.sh
            content: 'export PATH="{{ fworch_home }}/bin:$PATH"'
            mode: "0644"

  become: true
  environment: "{{ proxy_env }}"
