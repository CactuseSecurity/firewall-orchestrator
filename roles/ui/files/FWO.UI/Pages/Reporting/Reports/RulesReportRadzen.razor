@inject UserConfig userConfig
@using FWO.Report
@using FWO.Report.Data
@using FWO.Ui.Display

<TreeTable TItem="Rule" Columns="Columns" Nodes="treeData">
    <CellTemplate Context="item">
        @item.Name
    </CellTemplate>
</TreeTable>

@code {
    [Parameter]
    public ReportType SelectedReportType { get; set; }

    [Parameter]
    public List<ManagementReport> Managements { get; set; } = new();
    private NatRuleDisplayHtml? RuleDisplay;
    private bool Recertification { get; set; } = false;

    List<Rule> Rules;
    List<string> Columns = new List<string>() { "No.", "Name", "Source", "Destination" };

    List<TreeNode<Rule>> treeData;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
            
        var management = Managements.Select(mgt => new ManagementReportController(mgt)).First();
        var device = management.Devices.Select(dev => DeviceReportController.FromDeviceReport(dev)).First();

        var ungroupedRules = ReportRules.GetAllRulesOfGateway(device, management);
        treeData = BuildTreeData(ungroupedRules.ToList());
    }

    private List<TreeNode<Rule>> BuildTreeData(List<Rule> rules)
    {
        // Group by RulebaseId (or adjust the criteria as needed)
        var grouped = rules
            .GroupBy(r => r.RulebaseId)
            .OrderBy(g => g.Key);

        var tree = new List<TreeNode<Rule>>();

        foreach (var group in grouped)
        {
            // Create a node for the section, if available
            if (!string.IsNullOrEmpty(group.Key.ToString()))
            {
                var sectionNode = new TreeNode<Rule>
                {
                    Item = new Rule { Name = group.Key.ToString(), SectionHeader = group.Key.ToString() },
                    Children = group.Select(r => new TreeNode<Rule> { Item = r }).ToList()
                };
                tree.Add(sectionNode);
            }
            else
            {
                // Rules without SectionHeader directly at the top level
                tree.AddRange(group.Select(r => new TreeNode<Rule> { Item = r }));
            }
        }

        return tree;
    }

    private OutputLocation getActLocation()
    {
        return Recertification ? OutputLocation.certification : OutputLocation.report;
    }
}
