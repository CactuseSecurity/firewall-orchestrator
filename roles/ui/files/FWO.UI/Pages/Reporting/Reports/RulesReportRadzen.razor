@inject UserConfig userConfig
@using FWO.Report
@using FWO.Report.Data
@using FWO.Ui.Display

<TreeTable TItem="Rule" Columns="Columns" Nodes="treeData">
    <CellTemplate Context="item">
        @item.Name
    </CellTemplate>
</TreeTable>

@code {
    [Parameter]
    public ReportType SelectedReportType { get; set; }

    [Parameter]
    public List<ManagementReport> Managements { get; set; } = new();
    private NatRuleDisplayHtml? RuleDisplay;
    private bool Recertification { get; set; } = false;

    private bool Loading { get; set; }

    #region Radzen UI Boilerplate
    private RadzenDataGrid<Rule> RulesGrid;    
    private bool? GroupsExpanded { get; set; } = false;
    #endregion

    List<Rule> Rules;
    List<string> Columns = new List<string>() { "No.", "Name", "Source", "Destination" };

    List<TreeNode<Rule>> treeData;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        // await ShowLoading();

        // RuleDisplay = new NatRuleDisplayHtml(userConfig);

        var management = Managements.Select(mgt => new ManagementReportController(mgt)).First();
        var device = management.Devices.Select(dev => DeviceReportController.FromDeviceReport(dev)).First();

        var ungroupedRules = ReportRules.GetAllRulesOfGateway(device, management);

        treeData = new List<TreeNode<Rule>>();

        CreateOrderNumbers(ungroupedRules.ToList(), device);
    }


    private async Task ShowLoading()
    {
        Loading = true;

        await Task.Yield();

        Loading = false;
    }

    private OutputLocation getActLocation()
    {
        return Recertification ? OutputLocation.certification : OutputLocation.report;
    }

    public void CreateOrderNumbers(List<Rule> rules, DeviceReport device)
    {
        // Creates a dictionary with rulebase IDs as keys and lists of the corresponding rows as values.

        Dictionary<int, List<Rule>> rulesByRulebase = rules
            .GroupBy(r => r.RulebaseId)
            .ToDictionary(g => g.Key, g => g.OrderBy(r => r.OrderNumber).ToList());

        // Normalize actual order numbers to incremental int like form.
        NormalizeOrderNumbers(rulesByRulebase);



        // Creates a dictionary with rule IDs as keys and the rulebase link that has that rule as its from rule as values.

        Dictionary<int, RulebaseLink> linksByFromRuleId = device.RulebaseLinks
            .Where(link => !link.IsInitialRulebase() && link.FromRuleId.HasValue)
            .ToDictionary(link => link.FromRuleId!.Value, link => link);

        // Initialize other needed variables.

        List<Rule> changedRules = new();
        List<int> initialPath = new();
        int positionCounter = 1;
        int firstRulebaseId = device.RulebaseLinks.First(link => link.IsInitialRulebase()).NextRulebaseId;

        // If there are more than one layer path needs to be initialized here.

        if(device.RulebaseLinks.Any(link => link.LinkType == 2))    // ordered
        {
            initialPath.Add(1);
        }

        BuildOrderNumberTree(firstRulebaseId, initialPath, rulesByRulebase, linksByFromRuleId, changedRules, ref positionCounter, rules);
    }

    private static void NormalizeOrderNumbers(Dictionary<int, List<Rule>> rulesByRulebase)
    {
        foreach(KeyValuePair<int, List<Rule>> rulebaseRules in rulesByRulebase)
        {
            int relativeOrderNumber = 1;

            foreach(Rule rule in rulebaseRules.Value.ToList())
            {
                rule.RuleOrderNumber = relativeOrderNumber;
                relativeOrderNumber++;
            }
        }
    }

    private static void BuildOrderNumberTree(int rulebaseId, List<int> currentPath, Dictionary<int, List<Rule>> rulesByRulebase, Dictionary<int, RulebaseLink> linksByFromRuleId, List<Rule> changedRules, ref int positionCounter, List<Rule> rulebaseRules)
    {
        if(!rulesByRulebase.TryGetValue(rulebaseId, out var rules))
        {
            return;
        }

        for(int i = 0; i < rules.Count; i++)
        {
            Rule rule = rules[i];

            // Create duplicate if rulebase links make it necessary.

            if(changedRules.Contains(rule))
            {
                rule = rule.CreateClone();
                rulebaseRules.Add(rule);
            }

            // Write order numbers to rule object.

            List<int> path = new List<int>(currentPath) { rule.RuleOrderNumber };
            string dotted = string.Join(".", path);
            rule.DisplayOrderNumberString = dotted;
            rule.OrderNumber = positionCounter++;

            // Gather changed rules, to recognize if duplicate is necessary

            changedRules.Add(rule);

            // Handle link, if there is one that has this rule as its from rule.

            if(linksByFromRuleId.TryGetValue((int)rule.Id, out RulebaseLink? link))
            {
                switch(link.LinkType)
                {
                    case 2: // ordered
                        List<int> newPath = new() { path[0] + 1 };
                        BuildOrderNumberTree(link.NextRulebaseId, newPath, rulesByRulebase, linksByFromRuleId, changedRules, ref positionCounter, rulebaseRules);
                        break;

                    case 3: // inline
                        BuildOrderNumberTree(link.NextRulebaseId, path, rulesByRulebase, linksByFromRuleId, changedRules, ref positionCounter, rulebaseRules);
                        break;
                }
            }
        }
    }
}
