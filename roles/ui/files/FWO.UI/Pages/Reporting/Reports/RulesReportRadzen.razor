@inject UserConfig userConfig
@using FWO.Report
@using FWO.Report.Data
@using FWO.Ui.Display

<TreeTable TItem="Rule" Nodes="RulesNodes">
    <CellTemplate Context="item">
        @item.Name
    </CellTemplate>
</TreeTable>

@code {
    [Parameter]
    public List<ManagementReport> Managements { get; set; } = new();

    List<TreeNode<Rule>> RulesNodes;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
            
        ManagementReportController management = Managements.Select(mgt => new ManagementReportController(mgt)).First();
        DeviceReportController device = management.Devices.Select(dev => DeviceReportController.FromDeviceReport(dev)).First();

        List<Rule> ungroupedRules = ReportRules.GetAllRulesOfGateway(device, management).ToList();
                
        RulesNodes = BuildTreeData(ungroupedRules);
    }

    private List<TreeNode<Rule>> BuildTreeData(List<Rule> rules)
    {
        Dictionary<string, Rule> rulesByOrderNumber = new Dictionary<string, Rule>();
        Dictionary<string, TreeNode<Rule>> treeNodes = new Dictionary<string, TreeNode<Rule>>();
        List<TreeNode<Rule>> rootNodes = new List<TreeNode<Rule>>();

        // Create a node for each rule
        foreach (Rule rule in rules)
        {
            TreeNode<Rule> node = new TreeNode<Rule>
            {
                Item = rule,
                Children = new List<TreeNode<Rule>>()
            };
            
            // If it has a display order number string (like "1.2.3"), use it to structure the hierarchy
            if (!string.IsNullOrEmpty(rule.DisplayOrderNumberString))
            {
                treeNodes[rule.DisplayOrderNumberString] = node;
                rulesByOrderNumber[rule.DisplayOrderNumberString] = rule;
            }
        }

        // Build the tree structure based on hierarchical order numbers
        foreach (string key in treeNodes.Keys.OrderBy(k => k))
        {
            TreeNode<Rule> node = treeNodes[key];
            Rule rule = rulesByOrderNumber[key];
            
            // Find parent node
            int lastDotIndex = key.LastIndexOf('.');
            
            if (lastDotIndex > 0) 
            {
                // This is a child node, find its parent
                string parentKey = key.Substring(0, lastDotIndex);
                if (treeNodes.ContainsKey(parentKey))
                {
                    treeNodes[parentKey].Children.Add(node);
                }
                else 
                {
                    // Fallback if parent not found - add to root
                    rootNodes.Add(node);
                }
            }
            else 
            {
                // This is a root level node
                rootNodes.Add(node);
            }
        }

        // Handle rules without hierarchical order numbers or section headers
        // Group them by RulebaseId as a fallback
        IOrderedEnumerable<IGrouping<int, Rule>> rulesWithoutOrderNumber = rules
            .Where(r => string.IsNullOrEmpty(r.DisplayOrderNumberString))
            .GroupBy(r => r.RulebaseId)
            .OrderBy(g => g.Key);
            
        foreach (IGrouping<int, Rule> group in rulesWithoutOrderNumber)
        {
            // Create a node for the section, if available
            if (!string.IsNullOrEmpty(group.Key.ToString()))
            {
                TreeNode<Rule> sectionNode = new TreeNode<Rule>
                {
                    Item = new Rule { Name = group.Key.ToString(), SectionHeader = group.Key.ToString() },
                    Children = group.Select(r => new TreeNode<Rule> { Item = r }).ToList()
                };
                rootNodes.Add(sectionNode);
            }
            else
            {
                // Rules without SectionHeader directly at the top level
                rootNodes.AddRange(group.Select(r => new TreeNode<Rule> { Item = r }));
            }
        }

        return rootNodes;
    }
}
