@using FWO.Data.Report
@using FWO.Ui.Display
@inject UserConfig userConfig

@typeparam TItem

<div class="tree-table-viewport" id="treeTableViewport">
    <div class="d-flex mb-2">
        <button class="btn btn-sm btn-secondary me-1" @onclick="ExpandAll">
            <span class="oi oi-fullscreen-enter"></span>
        </button>
        <button class="btn btn-sm btn-secondary me-1" @onclick="CollapseAll">
            <span class="oi oi-fullscreen-exit"></span>
        </button>
        <span class="pt-1">|</span>
        <button class="btn btn-sm btn-outline-secondary mx-1">
            <i class="bi bi-eye-slash-fill me-1"></i>
            99
        </button>
        <div class="d-flex ms-auto">
            <input id="searchbar"
                   class="form-control form-control-sm"
                   placeholder="@userConfig.GetText("search")"
                   value="@SearchText"
                   @oninput="OnSearchInput"
                   @onkeyup="HandleSearchKeyPress" />
            @if (string.IsNullOrWhiteSpace(SearchText))
            {
                <button class="btn btn-sm btn-outline-secondary mx-1" @onclick="ApplySearch">
                    <span class="oi oi-magnifying-glass"></span>
                </button>
            }
            else
            {
                <button class="btn btn-sm btn-outline-secondary mx-1" @onclick="ClearSearch">
                    <span class="oi oi-x"></span>
                </button>
            }
        </div>
    </div>

    <div class="tree-table-container">
        <table class="tree-table">
            <thead>
                <tr>
                    <th @onclick="() => SortBy(nameof(Rule.Name))">
                        @(userConfig.GetText("name"))
                        @if(SortColumn == nameof(Rule.Name) && !NoSorting)
                        {
                            <span class="sort-icon @(SortAscending ? "oi oi-caret-bottom" : "oi oi-caret-top")"></span>
                        }
                    </th>
                    <th @onclick="() => SortBy(nameof(Rule.OrderNumber))">
                        @(userConfig.GetText("number"))
                        @if(SortColumn == nameof(Rule.OrderNumber) && !NoSorting)
                        {
                            <span class="sort-icon @(SortAscending ? "oi oi-caret-bottom" : "oi oi-caret-top")"></span>
                        }
                    </th>
                    <th>
                        @(userConfig.GetText("source_zone"))
                    </th>
                    <th>
                        @(userConfig.GetText("source"))
                    </th>
                    <th>
                        @(userConfig.GetText("destination_zone"))
                    </th>
                    <th>
                        @(userConfig.GetText("destination"))
                    </th>
                    <th>
                        @(userConfig.GetText("services"))
                    </th>
                    <th>
                        @(userConfig.GetText("action"))
                    </th>
                    <th>
                        @(userConfig.GetText("track"))
                    </th>
                    <th>
                        @(userConfig.GetText("enabled"))
                    </th>
                    <th>
                        @(userConfig.GetText("uid"))
                    </th>
                    <th>
                        @(userConfig.GetText("comment"))
                    </th>
                </tr>
            </thead>
            <tbody>
                @if(FilteredNodes is not null)
                {
                    @foreach(TreeNode<TItem> node in FilteredNodes)
                    {
                        <TreeTableRow TItem="TItem" Node="node" Level="0" CellTemplate="CellTemplate" OnToggle="ToggleNode" RuleDisplay="RuleDisplay" />
                    }
                }
            </tbody>
        </table>
    </div>
</div>

@code {
    [Parameter, EditorRequired]
    public required List<TreeNode<TItem>> Nodes { get; set; } = new();

    [Parameter, EditorRequired]
    public required RenderFragment<TItem> CellTemplate { get; set; }

    private string? SortColumn { get; set; }
    private bool SortAscending { get; set; } = true;
    private bool NoSorting { get; set; } = false;

    private NatRuleDisplayHtml? RuleDisplay;

    private string SearchText { get; set; } = string.Empty;
    public string AppliedSearchText { get; set; } = string.Empty;

    private Timer? debounceTimer;

    /// <summary>
    /// Initializes the component and sets up the rule display helper.
    /// </summary>
    protected override void OnInitialized()
    {
        RuleDisplay = new NatRuleDisplayHtml(userConfig);
    }

    /// <summary>
    /// Returns the filtered and sorted tree nodes for display.
    /// </summary>
    private IEnumerable<TreeNode<TItem>> FilteredNodes =>
        FilterAndSortNodes(Nodes);

    /// <summary>
    /// Filters and sorts the provided tree nodes based on search text and sorting options.
    /// </summary>
    private IEnumerable<TreeNode<TItem>> FilterAndSortNodes(IEnumerable<TreeNode<TItem>> nodes)
    {
        IEnumerable<TreeNode<TItem>> sorted = SortNodes(nodes);

        string filterText = string.IsNullOrWhiteSpace(AppliedSearchText) ? SearchText : AppliedSearchText;

        if(string.IsNullOrWhiteSpace(filterText) || typeof(TItem) != typeof(Rule))
            return sorted;

        IEnumerable<TreeNode<TItem>?> filtered = sorted
            .Select((TreeNode<TItem> n) => FilterNode(n, filterText))
            .Where((TreeNode<TItem>? n) => n != null);

        return filtered.Cast<TreeNode<TItem>>();
    }

    /// <summary>
    /// Recursively filters a tree node and its children based on the filter text.
    /// </summary>
    private TreeNode<TItem>? FilterNode(TreeNode<TItem> node, string filterText)
    {
        if (typeof(TItem) == typeof(Rule))
        {
            Rule? rule = node.Item as Rule;
            bool match =
                (rule?.Name?.Contains(filterText, StringComparison.OrdinalIgnoreCase) ?? false) ||
                (rule?.Comment?.Contains(filterText, StringComparison.OrdinalIgnoreCase) ?? false) ||
                (rule?.Source?.Contains(filterText, StringComparison.OrdinalIgnoreCase) ?? false) ||
                (rule?.Destination?.Contains(filterText, StringComparison.OrdinalIgnoreCase) ?? false);

            if (match)
            {
                return node;
            }

            var filteredChildren = node.Children
                .Select(child => FilterNode(child, filterText))
                .Where(child => child != null)
                .Cast<TreeNode<TItem>>()
                .ToList();

            if (filteredChildren.Count > 0)
            {
                return new TreeNode<TItem>
                {
                    Item = node.Item,
                    IsExpanded = node.IsExpanded,
                    Children = filteredChildren
                };
            }
            else
            {
                return null;
            }
        }
        return node;
    }

    /// <summary>
    /// Sorts the tree nodes based on the selected column and sort direction.
    /// </summary>
    private IEnumerable<TreeNode<TItem>> SortNodes(IEnumerable<TreeNode<TItem>> nodes)
    {
        if(NoSorting)
        {
            return nodes;
        }

        if(typeof(TItem) == typeof(Rule))
        {
            if(SortColumn == nameof(Rule.Name))
            {
                return SortAscending
                    ? nodes.OrderBy((TreeNode<TItem> n) => ((Rule)(object)n.Item).Name)
                    : nodes.OrderByDescending((TreeNode<TItem> n) => ((Rule)(object)n.Item).Name);
            }
            else if(SortColumn == nameof(Rule.OrderNumber))
            {
                return SortAscending
                    ? nodes.OrderBy((TreeNode<TItem> n) => ((Rule)(object)n.Item).OrderNumber)
                    : nodes.OrderByDescending((TreeNode<TItem> n) => ((Rule)(object)n.Item).OrderNumber);
            }
        }
        return nodes;
    }

    /// <summary>
    /// Handles sorting logic when a column header is clicked.
    /// </summary>
    private void SortBy(string column)
    {
        if(SortColumn == column)
        {
            if(SortAscending == false)
            {
                NoSorting = true;
                SortAscending = true;
            }
            else
            {
                SortAscending = false;
                NoSorting = false;
            }
        }
        else
        {
            SortColumn = column;
            SortAscending = true;
            NoSorting = false;
        }
    }

    /// <summary>
    /// Toggles the expanded state of a tree node.
    /// </summary>
    private void ToggleNode(TreeNode<TItem> node)
    {
        node.IsExpanded = !node.IsExpanded;
    }

    /// <summary>
    /// Expands all nodes in the tree.
    /// </summary>
    private void ExpandAll()
    {
        SetNodesExpandedState(Nodes, true);
        StateHasChanged();
    }

    /// <summary>
    /// Collapses all nodes in the tree.
    /// </summary>
    private void CollapseAll()
    {
        SetNodesExpandedState(Nodes, false);
        StateHasChanged();
    }

    /// <summary>
    /// Recursively sets the expanded state for all nodes in the tree.
    /// </summary>
    private void SetNodesExpandedState(IEnumerable<TreeNode<TItem>> nodes, bool isExpanded)
    {
        if(nodes == null) return;

        foreach(TreeNode<TItem> node in nodes)
        {
            node.IsExpanded = isExpanded;
            SetNodesExpandedState(node.Children, isExpanded);
        }
    }

    /// <summary>
    /// Handles the key press event in the search bar, applying search on Enter.
    /// </summary>
    private void HandleSearchKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            debounceTimer?.Dispose(); //Cancelling debounce because we are applying search immediately
            ApplySearch();
        }
    }

    /// <summary>
    /// Applies the current search text as the filter.
    /// </summary>
    private void ApplySearch()
    {
        AppliedSearchText = SearchText;
        StateHasChanged();
    }

    /// <summary>
    /// Clears the search text and removes the filter.
    /// </summary>
    private void ClearSearch()
    {
        SearchText = string.Empty;
        AppliedSearchText = string.Empty;
        StateHasChanged();
    }

    /// <summary>
    /// Handles the input event in the search bar with debounce.
    /// </summary>
    private void OnSearchInput(ChangeEventArgs e)
    {
        SearchText = e.Value?.ToString() ?? string.Empty;

        debounceTimer?.Dispose();
        debounceTimer = new Timer(_ =>
        {
            InvokeAsync(() =>
            {
                AppliedSearchText = SearchText;
                StateHasChanged();
            });
        }, null, GlobalConst.SearchInputDebounceTime, Timeout.Infinite);
    }

    /// <summary>
    /// Disposes the debounce timer when the component is disposed.
    /// </summary>
    public void Dispose()
    {
        debounceTimer?.Dispose();
    }
}