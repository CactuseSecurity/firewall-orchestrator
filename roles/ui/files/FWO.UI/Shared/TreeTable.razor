@using FWO.Data.Report
@using FWO.Ui.Display
@inject UserConfig userConfig

@typeparam TItem

<div class="tree-table-viewport" id="treeTableViewport">
    <div class="d-flex mb-2">
        <button class="btn btn-sm btn-secondary me-1" @onclick="ExpandAll">
            <span class="oi oi-fullscreen-enter"></span>
        </button>
        <button class="btn btn-sm btn-secondary me-1" @onclick="CollapseAll">
            <span class="oi oi-fullscreen-exit"></span>
        </button>
        <span class="pt-1">|</span>
        <button class="btn btn-sm btn-outline-secondary mx-1">
            <span class="oi oi-bolt"></span>
        </button>
        <div class="d-flex ms-auto">
            <input id="searchbar" class="form-control form-control-sm" placeholder="@userConfig.GetText("search")" @bind="SearchText" @bind:event="oninput" @onkeyup="HandleSearchKeyPress" />
            @if (string.IsNullOrWhiteSpace(SearchText))
            {
                <button class="btn btn-sm btn-outline-secondary mx-1" @onclick="ApplySearch">
                    <span class="oi oi-magnifying-glass"></span>
                </button>
            }
            else
            {
                <button class="btn btn-sm btn-outline-secondary mx-1" @onclick="ClearSearch">
                    <span class="oi oi-x"></span>
                </button>
            }
        </div>
    </div>

    <div class="tree-table-container">
        <table class="tree-table">
            <thead>
                <tr>
                    <th @onclick="() => SortBy(nameof(Rule.Name))">
                        @(userConfig.GetText("name"))
                        @if(SortColumn == nameof(Rule.Name) && !NoSorting)
                        {
                            <span class="sort-icon @(SortAscending ? "oi oi-caret-bottom" : "oi oi-caret-top")"></span>
                        }
                    </th>
                    <th @onclick="() => SortBy(nameof(Rule.OrderNumber))">
                        @(userConfig.GetText("number"))
                        @if(SortColumn == nameof(Rule.OrderNumber) && !NoSorting)
                        {
                            <span class="sort-icon @(SortAscending ? "oi oi-caret-bottom" : "oi oi-caret-top")"></span>
                        }
                    </th>
                    <th>
                        @(userConfig.GetText("source_zone"))
                    </th>
                    <th>
                        @(userConfig.GetText("source"))
                    </th>
                    <th>
                        @(userConfig.GetText("destination_zone"))
                    </th>
                    <th>
                        @(userConfig.GetText("destination"))
                    </th>
                    <th>
                        @(userConfig.GetText("services"))
                    </th>
                    <th>
                        @(userConfig.GetText("action"))
                    </th>
                    <th>
                        @(userConfig.GetText("track"))
                    </th>
                    <th>
                        @(userConfig.GetText("enabled"))
                    </th>
                    <th>
                        @(userConfig.GetText("uid"))
                    </th>
                    <th>
                        @(userConfig.GetText("comment"))
                    </th>
                </tr>
            </thead>
            <tbody>
                @if(FilteredNodes is not null)
                {
                    @foreach(TreeNode<TItem> node in FilteredNodes)
                    {
                        <TreeTableRow TItem="TItem" Node="node" Level="0" CellTemplate="CellTemplate" OnToggle="ToggleNode" RuleDisplay="RuleDisplay" />
                    }
                }
            </tbody>
        </table>
    </div>
</div>

@code {
    [Parameter, EditorRequired]
    public required List<TreeNode<TItem>> Nodes { get; set; } = new();

    [Parameter, EditorRequired]
    public required RenderFragment<TItem> CellTemplate { get; set; }

    private string? SortColumn { get; set; }
    private bool SortAscending { get; set; } = true;
    private bool NoSorting { get; set; } = false;

    private NatRuleDisplayHtml? RuleDisplay;

    private string SearchText { get; set; } = string.Empty;
    private string AppliedSearchText { get; set; } = string.Empty;

    protected override void OnInitialized()
    {
        RuleDisplay = new NatRuleDisplayHtml(userConfig);
    }

    private IEnumerable<TreeNode<TItem>> FilteredNodes =>
        FilterAndSortNodes(Nodes);

    private IEnumerable<TreeNode<TItem>> FilterAndSortNodes(IEnumerable<TreeNode<TItem>> nodes)
    {
        IEnumerable<TreeNode<TItem>> sorted = SortNodes(nodes);

        string filterText = string.IsNullOrWhiteSpace(AppliedSearchText) ? SearchText : AppliedSearchText;
        
        if(string.IsNullOrWhiteSpace(filterText) || typeof(TItem) != typeof(Rule))
            return sorted;

        IEnumerable<TreeNode<TItem>?> filtered = sorted
            .Select((TreeNode<TItem> n) => FilterNode(n, filterText))
            .Where((TreeNode<TItem>? n) => n != null);

        return filtered.Cast<TreeNode<TItem>>();
    }

    private TreeNode<TItem>? FilterNode(TreeNode<TItem> node, string filterText)
    {
        if(typeof(TItem) == typeof(Rule))
        {
            Rule? rule = node.Item as Rule;
            bool match =
                (rule?.Name?.Contains(filterText, StringComparison.OrdinalIgnoreCase) ?? false) ||
                (rule?.Comment?.Contains(filterText, StringComparison.OrdinalIgnoreCase) ?? false) ||
                (rule?.Source?.Contains(filterText, StringComparison.OrdinalIgnoreCase) ?? false) ||
                (rule?.Destination?.Contains(filterText, StringComparison.OrdinalIgnoreCase) ?? false);

            List<TreeNode<TItem>?> filteredChildren = node.Children
                .Select((TreeNode<TItem> child) => FilterNode(child, filterText))
                .Where((TreeNode<TItem>? child) => child != null)
                .ToList();

            List<TreeNode<TItem>> filteredChildrenNonNull = filteredChildren
                .Cast<TreeNode<TItem>>()
                .ToList();

            if(match || filteredChildrenNonNull.Count > 0)
            {
                return new TreeNode<TItem>
                {
                    Item = node.Item,
                    IsExpanded = node.IsExpanded,
                    Children = filteredChildrenNonNull
                };
            }
            else
            {
                return null;
            }
        }

        return node;
    }

    private IEnumerable<TreeNode<TItem>> SortNodes(IEnumerable<TreeNode<TItem>> nodes)
    {
        if(NoSorting)
        {
            return nodes;
        }

        if(typeof(TItem) == typeof(Rule))
        {
            if(SortColumn == nameof(Rule.Name))
            {
                return SortAscending
                    ? nodes.OrderBy((TreeNode<TItem> n) => ((Rule)(object)n.Item).Name)
                    : nodes.OrderByDescending((TreeNode<TItem> n) => ((Rule)(object)n.Item).Name);
            }
            else if(SortColumn == nameof(Rule.OrderNumber))
            {
                return SortAscending
                    ? nodes.OrderBy((TreeNode<TItem> n) => ((Rule)(object)n.Item).OrderNumber)
                    : nodes.OrderByDescending((TreeNode<TItem> n) => ((Rule)(object)n.Item).OrderNumber);
            }
        }
        return nodes;
    }

    private void SortBy(string column)
    {
        if(SortColumn == column)
        {
            if(SortAscending == false)
            {
                NoSorting = true;
                SortAscending = true;
            }
            else
            {
                SortAscending = false;
                NoSorting = false;
            }
        }
        else
        {
            SortColumn = column;
            SortAscending = true;
            NoSorting = false;
        }
    }

    private void ToggleNode(TreeNode<TItem> node)
    {
        node.IsExpanded = !node.IsExpanded;
    }

    private void ExpandAll()
    {
        SetNodesExpandedState(Nodes, true);
        StateHasChanged();
    }

    private void CollapseAll()
    {
        SetNodesExpandedState(Nodes, false);
        StateHasChanged();
    }

    private void SetNodesExpandedState(IEnumerable<TreeNode<TItem>> nodes, bool isExpanded)
    {
        if(nodes == null) return;

        foreach(TreeNode<TItem> node in nodes)
        {
            node.IsExpanded = isExpanded;
            SetNodesExpandedState(node.Children, isExpanded);
        }
    }

    private void HandleSearchKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            ApplySearch();
        }
    }

    private void ApplySearch()
    {
        AppliedSearchText = SearchText;
        StateHasChanged();
    }

    private void ClearSearch()
    {
        SearchText = string.Empty;
        AppliedSearchText = string.Empty;
        StateHasChanged();
    }
}